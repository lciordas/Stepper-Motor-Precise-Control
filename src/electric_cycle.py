from math import cos, sin, pi


def calculate_currents_advanced(theta):
    """
    Calculates the current intensity that rotates the stator magnetic field by a given angle.
    
    This function assumes a that we are working with a bipolar stepper motor with two phases.
    Each phase has four windings around four poles, positioned around the stator as follows:
    Phase A poles: A1 @ 0   , A2 @ 1/2π, A3 @ π   , A4 @ 3/2π 
    Phase B poles: B1 @ 1/4π, B2 @ 3/4π, B3 @ 5/4π, B4 @ 7/4π

    The windings around the poles are such that passing an electric current through the phase 
    generates alternating magnetic polarities:
    Positive current through Phase A:  A1 - Nord , A2 - South, A3 - Nord , A4 - South
    Negative current through Phase A:  A1 - South, A2 - Nord , A3 - South, A4 - Nord
    Positive current through Phase B:  B1 - Nord , B2 - South, B3 - Nord , B4 - South
    Negative current through Phase B:  B1 - South, B2 - Nord , B3 - South, B4 - Nord

    We define the reference magnetic configuration as the magnetic field produced by the stator
    when the poles are oriented as described above and max positive current is flowing through 
    Phase A, while no current is flowing through Phase B. By cutting the current through Phase A 
    and passing max positive current through Phase B we rotate the magnetic field clockwise by 45°.

    Imagine having a dial with an arrow, which when pointing upwards corresponds to the stator 
    generating the reference magnetic field. As we turn this dial, the magnetic field generated by
    the stator rotates like the dial's arrow. This function implements the behavior of such a dial.

    The current intensity is a expressed as a number between -1.0 and 1.0, where 1.0 means fully
    energizing the phase in one direction, and -1.0 means fully energizing the phase with the 
    electric current flowing in the opposite direction. Which direction corresponds to +1.0 and
    which direction to -1.0 is both arbitrary and irrelevant.

    Parameters:
        theta - the angle by which to rotate the reference magnetic field (clockwise is positive)
    
    Returns: 
        a tuple: (PhaseA current intensity, PhaseB current intensity)
    """

    # Since the magnetic field produced by the stator is invariant to rotations
    # by an angle of N * π, we map the angle of magnetic rotation to [0, π).
    # Example: rotating the reference field by 195° is the same as rotating it by 15°.
    
    theta = theta % pi

    # The angle of rotation is measured clockwise, relative to the vertical,
    # therefore the [0, π) range encompases the left semi-circle. We divide
    # this semi-circle into 4 equal sectors:
    #   Sector 1: [0   , 1/4π)
    #   Sector 2: [1/4π, 1/2π)
    #   Sector 3: [1/2π, 3/4π)
    #   Sector 4: [3/4π, π)
    # The sector boundaries are the positions of the stator poles (see docstring)
    
    sector_sz = pi/4

    # We map the given angle of rotation to a sector and a relative angle within that sector:
    # Examples:
    #   theta = 15° => sector 1, theta = 15° 
    #   theta = 65° => sector 2, theta = 20°
    #   theta = 90° => sector 3, theta =  0°
    # This reduces the problem of rotating the field by an angle in [0, π) to that of 
    # rotating it by an angle in [0, π/4). This is possible since the symmetry of the
    # stator means that all sectors look the same.

    sector = theta // sector_sz + 1
    theta  = theta - (sector-1) * sector_sz

    # Consider two axes that form a 45° angle, and a unit vector whose direction lies between them.
    # We call an axis the "left axis"  if rotating it 45° clockwise         aligns it with the other given axis.
    # We call an axis the "right axis" if rotating it 45° counter-clockwise aligns it with the other given axis.
    # If 'theta' is the angle between the unit vector and the left axis, then its decomposition along the two
    # axes is:
    #   left  component = cos(theta) - sin(theta)
    #   right component = sqrt(2) * sin(theta)
    #
    # This is the situation we face when decomposing the rotated magnetic field along the direction of the two
    # stator poles that bracket it. This decomposition is useful because we control the intesity of the field
    # along the direction that connects opposing poles. Setting the field magnitude to 1, its components are:

    B_left  = cos(theta) - sin(theta)
    B_right = sqrt(2) * sin(theta)

    # Below we translate magnetic field intensity to current intensity.
    # We assume that the magnitude of the magnetic field is proportional with the current intensity and we 
    # set the proportionality constant to 1. 
    # Also note the sign of the current: generating the same magnetic field along the A1 - A3 vs A2 - A4 
    # direction requires flipping the direction of the current through Phase A (as polarities of poles 
    # A1, A2, A3, A4 alternates).
    
    # left  direction: line connecting poles A1 - A3
    # right direction: line connecting poles B1 - B3        
    if sector == 1:
        Ia = +B_left
        Ib = +B_right

    # left  direction: line connecting poles B1 - B3            
    # right direction: line connecting poles A2 - A4
    elif sector == 2:
        Ia = -B_right 
        Ib = +B_left

    # left  direction: line connecting poles A2 - A4
    # right direction: line connecting poles B2 - B4            
    elif sector == 3:
        Ia = -B_left
        Ib = -B_right

    # left  direction: line connecting poles B2 - B4            
    # right direction: line connecting poles A1 - A3
    elif sector == 4:
        Ia = +B_right
        Ib = -B_left

    return Ia, Ib


def calculate_currents_sinusoidal(cycle_position):
    """
    Calculate phase currents using simple sinusoidal interpolation.

    This function provides a basic sinusoidal waveform for the two motor phases,
    with a 90-degree phase shift between them. This is the standard approach for
    smooth micro-stepping in stepper motors.

    Parameters:
        cycle_position (float): Position within the electrical cycle, ranging from
                                0.0 (start) to 1.0 (full cycle).
                                
    Returns:
        tuple: A pair (IA, IB) where:
               - IA: Current intensity for Phase A (cos wave), range [-1.0, +1.0]
               - IB: Current intensity for Phase B (sin wave), range [-1.0, +1.0]
    """
    theta = 2*pi*cycle_position
    return cos(theta), sin(theta)

def calculate_electric_cycle(num_microsteps, current_calculator):
    """
    Generate the sequence of electrical configurations for micro-stepping control.

    This function calculates the current intensities for phases A and B throughout
    a complete electrical cycle, divided into micro-steps. The cycle consists of
    4 full steps, each subdivided into the specified number of micro-steps.

    At key points in the cycle (0%, 25%, 50%, 75%), exact values are enforced to
    avoid floating-point rounding errors:
      - n = 0:                Phase A at +1, Phase B at  0 (  0° position)
      - n = num_microsteps:   Phase A at  0, Phase B at +1 ( 90° position)
      - n = 2*num_microsteps: Phase A at -1, Phase B at  0 (180° position)
      - n = 3*num_microsteps: Phase A at  0, Phase B at -1 (270° position)

    Between these cardinal points, the provided current calculator function is used
    to determine the current intensities for smooth transitions.

    Parameters:
        num_microsteps (int): Number of micro-steps per full step (a power of 2)

        current_calculator (function): A function that calculates current intensities
                                       for a given position in the electrical cycle.
                                       Signature: current_calculator(cycle_position) -> (IA, IB)
                                       where:
                                        - cycle_position: float between 0.0 and 1.0 representing
                                          the position within one complete electrical cycle
                                        - Returns: tuple (IA, IB) with current intensities for
                                          Phase A and Phase B (values between -1.0 and 1.0)

    Returns:
        list: A list of tuples (IA, IB) where:
              - IA: Current intensity for Phase A (-1.0 to +1.0)
              - IB: Current intensity for Phase B (-1.0 to +1.0)
              The list contains 4*num_microsteps entries representing one
              complete electrical cycle.
    """

    # To move the rotor in full steps, we cycle the electric configuration through 4 stages.
    # When we break a full step into micro-steps, the number of stages increases proportionally
    # (we complete the same electric cycle, but in finer steps).
    num_stages = 4 * num_microsteps

    # For each stage store a tuple (IA, IB): the signed 
    # intensity of electric curent through each phase.
    electric_cycle = []
    
    for n in range(num_stages):
               
        # Regardless of how we compute the intermediate electrical states used to move the rotor
        # between full steps, the electrical configuration at certain key points in the cycle
        # is always known: at 0%, 25%, 50%, and 75% of the electrical period, one phase is fully
        # energized and the other phase is completely off. To avoid floating-point rounding errors, 
        # we explicitly hard-code the electrical configuration for these special points. 
        if n == 0:
            IA, IB = (+1, 0)
        elif n == num_microsteps:
            IA, IB = (0, +1)
        elif n == 2 * num_microsteps:
            IA, IB = (-1, 0)
        elif n == 3 * num_microsteps:
            IA, IB = (0, -1)

        # In between full steps.
        else:
            IA, IB = current_calculator(n/num_stages)
            
        electric_cycle.append((IA, IB))
    return electric_cycle
